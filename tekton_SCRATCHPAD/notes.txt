k3d cluster create tekton
kubectl get ns

# Install Tekton Pipelines
helm repo add cdf https://cdfoundation.github.io/tekton-helm-chart/
helm upgrade --install tekton cdf/tekton-pipeline --set-string featureFlags.running-in-environment-with-injected-sidecars="false"

# Create a hello world Task containing 1 step
cat <<EOF > hello-world-task.yaml
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: hello
spec:
  steps:
    - name: echo
      image: alpine
      script: |
        #!/bin/sh
        echo "Hello World"
EOF

kubectl apply -f hello-world-task.yaml

# Create a TaskRun to, err, run the task
cat <<EOF > hello-world-task-run.yaml
apiVersion: tekton.dev/v1beta1
kind: TaskRun
metadata:
  name: hello-task-run
spec:
  taskRef:
    name: hello
EOF

kubectl apply -f hello-world-task-run.yaml

# Get the task run
kubectl get taskrun hello-task-run

# Keep repeating that command until SUCCEEDED shows True

# Now get the logs
kubectl logs --selector=tekton.dev/taskRun=hello-task-run

You should see:

Defaulted container "step-echo" out of: step-echo, place-tools (init), place-scripts (init)
Hello World

# That was a standalone task, but how are tasks chained together to form pipelines?

# Create a second task called goodbye which will take an input parameter for username and print it back to the username
cat <<EOF > goodbye-world-task.yaml
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: goodbye
spec:
  params:
  - name: username
    type: string
  steps:
    - name: goodbye
      image: ubuntu
      script: |
        #!/bin/bash
        echo "Goodbye $(params.username)!"
EOF

kubectl apply --filename goodbye-world-task.yaml

When a Task is part of a Pipeline, Tekton creates a TaskRun object for every task in the Pipeline. So no need to explicitly create the TaskRun objects

# Now create a pipeline which references those Tasks in order

cat <<EOF > hello-goodbye-pipeline.yaml
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: hello-goodbye
spec:
  params:
  - name: username
    type: string
  tasks:
    - name: hello
      taskRef:
        name: hello
    - name: goodbye
      runAfter:
        - hello
      taskRef:
        name: goodbye
      params:
      - name: username
        value: $(params.username)
EOF

kubectl apply -f hello-goodbye-pipeline.yaml

# Create a PipelineRun to, err, execute the pipeline
# It is here that we pass in the username
cat <<EOF > hello-goodbye-pipeline-run.yaml
apiVersion: tekton.dev/v1beta1
kind: PipelineRun
metadata:
  name: hello-goodbye-run2
spec:
  pipelineRef:
    name: hello-goodbye
  params:
  - name: username
    value: "Adam"
EOF

# Run the pipeline
kubectl apply -f hello-goodbye-pipeline-run.yaml

# Get the pipelineruns status
kubectl get pipelineruns

If it works, you should see:

NAME                SUCCEEDED   REASON      STARTTIME   COMPLETIONTIME
hello-goodbye-run   True        Succeeded   83s         58s

kubectl logs -l tekton.dev/pipelineRun=hello-goodbye-run

# Note: If an error occurs, pipelineruns are named uniquelly.
# In other words, you need to either delete the pipelinerun and re-apply the YAML
# Or create hello-goodbye-pipelinerun2

# Use Tekton triggers to trigger pipeline runs from "external" events

# Install Tekton triggers
kubectl apply -f https://storage.googleapis.com/tekton-releases/triggers/latest/release.yaml
kubectl apply -f https://storage.googleapis.com/tekton-releases/triggers/latest/interceptors.yaml


# Create a trigger template
# this defines what happens when an event is detected

cat <<EOF > trigger-template.yaml
apiVersion: triggers.tekton.dev/v1beta1
kind: TriggerTemplate
metadata:
  name: hello-template
spec:
  params:
  - name: username
    default: "Kubernetes"
  resourcetemplates:
  - apiVersion: tekton.dev/v1beta1
    kind: PipelineRun
    metadata:
      generateName: hello-goodbye-run-
    spec:
      pipelineRef:
        name: hello-goodbye
      params:
      - name: username
        value: $(tt.params.username)
EOF

kubectl apply -f trigger-template.yaml

# Create a TriggerBinding
A TriggerBinding executes the TriggerTemplate, the same way you had to create a PipelineRun to execute the Pipeline.
This TriggerBinding gets some information and saves it in the username variable.

cat <<EOF > trigger-binding.yaml
apiVersion: triggers.tekton.dev/v1beta1
kind: TriggerBinding
metadata:
  name: hello-binding
spec: 
  params:
  - name: username
    value: $(body.username)
EOF

kubectl apply -f trigger-binding.yaml

# Create an EventListener
The EventListener object encompasses both the TriggerTemplate and the TriggerBinding. Create a file named event-listener.yaml and add the following:

cat <<EOF > event-listener.yaml
apiVersion: triggers.tekton.dev/v1beta1
kind: EventListener
metadata:
  name: hello-listener
spec:
  serviceAccountName: tekton-robot
  triggers:
    - name: hello-trigger 
      bindings:
      - ref: hello-binding
      template:
        ref: hello-template
EOF

The EventListener requires a service account to run.

cat <<EOF > rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tekton-robot
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: triggers-example-eventlistener-binding
subjects:
- kind: ServiceAccount
  name: tekton-robot
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: tekton-triggers-eventlistener-roles
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: triggers-example-eventlistener-clusterbinding
subjects:
- kind: ServiceAccount
  name: tekton-robot
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: tekton-triggers-eventlistener-clusterroles
EOF

kubectl apply -f rbac.yaml

# Port forward to communicate from outside the cluster
kubectl port-forward service/el-hello-listener 8080

# Open a new terminal and send in an event
curl -X GET -v -H 'content-Type: application/json' -d "{\"username\": \"Tekton2\"}" http://localhost:8080

kubectl get pipelineruns

You should see two - the original one and the new one with a random ID at the end.

Use the name of the "random ID" pipeline run in the following command

kubectl describe pipelinerun hello-goodbye-run-l46tq
kubectl logs -l tekton.dev/pipelineRun=hello-goodbye-run

# Note, you can also make a note of the eventID returned from the curl command and do:

kubectl logs -l triggers.tekton.dev/triggers-eventid=02c560c2-fe35-4635-803d-b12626714604